1.Sorting:
  - Bubble Sort
  - Insertion Sort
  - Selection Sort
  - Merge Sort
  - Quick Sort

2.Searching
  - Linear Search
  - Binary Search
  
3.Stack
  - LinkedList Implementation

5.Queue
  - LinkedList Implementation

6. Binary Tree 
  - LinkedList Implementaton
  - Traversal (Recursive + Iterative)
  - BFS

6. Binary Search Tree :
  - LinkedList Implementation https://www.baeldung.com/java-binary-tree 
7. 
----------------------------------------------------------------------


1. Kadane's Algorithm : https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/
2. Permutation of Given String :  https://www.geeksforgeeks.org/write-a-c-program-to-print-all-permutations-of-a-given-string
3. Int To Roman : https://leetcode.com/submissions/detail/420387969/
4. Roman To Integer : https://leetcode.com/submissions/detail/420392801/
5. Longest common Prefix  https://leetcode.com/submissions/detail/409570119/
6. Longest Common Subsequence 
7. PairWise Swap https://leetcode.com/submissions/detail/451134399/
8. Next Greater Element(Stack) https://github.com/maainul/Java/blob/master/src/interviewQuestions/_NextGreaterElementStackAndSameOrderAsInput.java
9. Stack Using  2 queue https://leetcode.com/problems/implement-stack-using-queues/
10. Queue using 2 stack https://github.com/maainul/Java/blob/master/src/interviewQuestions/ImplementQueueUsingStackOperation.java
11. Stack and queue Linked List Implementation
12. Parenthesis check https://leetcode.com/problems/valid-parentheses/
13. Maximum Depth of a Binary tree https://github.com/maainul/Java/blob/master/src/interviewQuestions/_BinaryTree_FindMaximumHeightOfABinaryTree.md
14. DFS https://github.com/maainul/Java/blob/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/AllTraversalInOneFile/BinaryTree.java
15. BFS https://github.com/maainul/Java/tree/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/_12_LevelOrderBinaryTreeTraversal
16. Spiral Order Traversal https://github.com/maainul/Java/tree/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/_13_SpiralTreeTraversal
17. Sort Stack https://github.com/maainul/Java/blob/master/src/interviewQuestions/Stack_SortStackUsingTwoStack.java
18. Minimun value of Stack : https://github.com/maainul/Java/blob/master/src/interviewQuestions/Stack_GetMinValueFromStack.java
19. Recursive string reverse https://www.geeksforgeeks.org/program-reverse-string-iterative-recursive/
20. How to Find all Pairs in Array of Integers Whose sum is Equal to a Given Number
21. 24. Number Power of two
22. Reverse A Number,Palindrome,Armstrong,Prime,Factorial,Fibonacci
23. Depth of Binary tree
24. leaf node of binary tree


----------------------------------------------------------------------------------------

# Problems
https://javarevisited.blogspot.com/2011/06/top-programming-interview-questions.html#axzz6nnt0cci4


https://www.java67.com/2018/06/data-structure-and-algorithm-interview-questions-programmers.html#ixzz6oPEcRtVA

# STRING
1. Print duplicate characters from String? (solution)
2. Check if two Strings are anagrams of each other? (solution)
3. Print first non repeated character from String? (solution)
4.Reverse a given String using recursion? (solution)
5. Check if a String contains only digits? (solution)
6. Find duplicate characters in a String? (solution)
7. Count a number of vowels and consonants in a given String? (solution)
8. Count the occurrence of a given character in String? (solution)
9. Find all permutations of String? (solution)
10. Reverse words in a given sentence without using any library method? (solution)
11. Check if two String is a rotation of each other? (solution)
12. Check if the given String is Palindrome? (solution)
# ARRAY
13. Find a missing number in a given integer array of 1 to 100? (solution)
14. Find the duplicate number on a given integer array? (solution)
15. The largest and smallest number in an unsorted integer array? (solution)
16. Find all pairs of integer arrays whose sum is equal to a given number? (solution)
17. Find duplicate numbers in an array if it contains multiple duplicates? (solution)
18. Remove duplicates from the given array in Java? (solution)
19. Sort an integer array in place using the QuickSort algorithm? (solution)
20. Remove duplicates from an array in place? (solution)
21. Reverse an array in place in Java? (solution)
22. Find multiple missing numbers in a given integer array with duplicates? (solution)
23. Perform a binary search in a given array? (solution)
24. Transpose a Matrix? (solution)
25. Add or subtract two Matrices? (solution)
26. Multiply two Matrices in Java? (solution)
27. Calculate the average of all numbers in a given array? (solution)
28. Question 10 : Write java Program to Find Smallest and Largest Element in an Array.
29. Question 11 : Find missing number in the array.
30. Question 12 : Search an element in a rotated and sorted array.
31. Question 13 : Find minimum element in a sorted and rotated array.
32. Question 14: Find second largest number in an array
33. Question 15 : Find the number occurring odd number of times in an array
34. Question 16 : Find minimum number of platforms required for railway station
35. Question 17 : Find a Pair Whose Sum is Closest to zero in Array
36. Question 18 : Given a sorted array and a number x, find the pair in array whose sum is closest to x
37. Question 19 : Find all pairs of elements from an array whose sum is equal to given number
38. Question 20: Given an array of 0’s and 1’s in random order, you need to separate 0’s and 1’s in an array.
39. Question 21 : Separate odd and even numbers in an array
40. Question 22 : Given an array containing zeroes, ones and twos only. Write a function to sort the given array in O(n) time complexity.
41. Question 23 : Find local minima in array
42. Question 24 : Sliding window maximum in java
43. Question 25 : Count number of occurrences (or frequency) of each element in a sorted array
44. Question 26 : Find subarrays with a given sum in an array.
45. Question 27 : Find peak element in the array.
46. Question 28 : Find leaders in an array.
47. Question 29 : Count 1’s in sorted Binary Array.
48. Question 30 : Find the first repeating element in an array of integers.
49. Question 31 : Check if Array Elements are Consecutive.
50. Question 32 : Permutations of array in java.
51. Question 33 : Rotate an array by K positions.
52. Question 34 : Stock Buy Sell to Maximize Profit.
53. Question 35 : Find maximum difference between two elements such that larger element appears after the smaller number.
54. Question 36 : Search in a row wise and column wise sorted matrix.
55. Question 37 : Largest sum contiguous subarray.
56. Question 38 : Find the Contiguous Subarray with Sum to a Given Value in an array.
57. Question 39 : Longest Common Prefix in an array of Strings in java.
58. Question 40 : Find all subsets of a set (power set) in java.
# LINKEDLIST
59. Find the middle element of a singly linked list in one pass? (solution)
60. Find the 3rd node from the end in a singly linked list? (solution)
61. Check if a given linked list contains a cycle? Find the length of a singly linked list? (solution)
62. Reverse a linked list? (solution)
63. Remove duplicate nodes in an unsorted linked list? (solution)
64. Palindrome linked list
65. Find Intersection of Linked list
66. Pairwise swap

# BINARY TREE
67. DFS https://github.com/maainul/Java/blob/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/AllTraversalInOneFile/BinaryTree.java
68. BFS https://github.com/maainul/Java/tree/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/_12_LevelOrderBinaryTreeTraversal
69. Spiral Order Traversal https://github.com/maainul/Java/tree/master/src/dataStructureAndAlgorithm/Tree/BinaryTree/traversal/_13_SpiralTreeTraversal
70. Maximum Depth of a Binary tree https://github.com/maainul/Java/blob/master/src/interviewQuestions/_BinaryTree_FindMaximumHeightOfABinaryTree.md
71. Print all leaves of a binary search tree? (solution) https://www.geeksforgeeks.org/print-leaf-nodes-left-right-binary-tree/
72. Count a number of leaf nodes in a given binary tree? (solution) https://www.geeksforgeeks.org/write-a-c-program-to-get-count-of-leaf-nodes-in-a-binary-tree/
73. Question 63 : How to find maximum element in binary tree..https://www.geeksforgeeks.org/find-maximum-or-minimum-in-binary-tree/
# BINARY SEARCH TREE
78. Question 69 : Can you write an algorithm to insert a node in a binary search tree?
79. Question 70 : Can you write an algorithm to delete a node in a binary search tree.
80. Question 71 :  How can you find minimum and maximum elements in a binary search tree?
81. Question 72 : How to find the lowest common ancestor(LCA) in a binary search tree?
82. Question 73 : Find inorder successor in a Binary search Tree
83. Question 74 : Convert sorted array to balanced BST
84. Question 75 : Convert sorted Linked List to balanced BST
85. Question 76 : Check if a binary tree is binary search tree or not in java
# STACK
86. Sum of two linked lists using Stack? (program)
87. How do you implement a Queue using two Stacks? (answer)
88. Write a Java program to implement Stack using an array and linked list? (answer)
89. How do you implement Stack using Queues? (answer)
90. How to implement queue using stack
91. Given a binary tree, return the postorder traversal of its nodes' values, using Stack? (answer)
92. Difference between Stack and Queue data structure (answer)
93. Next greater element of stack
94. Sort stack
95. Find Minimum value from stack
# SORTING AND SEARCHING
96. Implement the Bubble Sort algorithm? (solution)
97. Implement Iterative QuickSort Algorithm? (solution)
98. Implement the Bucket Sort Algorithm? (solution)
99. Implement the Counting Sort Algorithm? (solution)
100. Implement the Insertion Sort Algorithm? (solution)
101. Implement a Merge Sort Algorithm? (solution)
102. Implement the Radix Sort Algorithm? (solution)
103. Implement Sieve of Eratosthenes Algorithm to find Prime numbers? (solution)
104. Find GCD of two numbers using Euclid's Algorithm? (solution)
# Graph
Question 86 : Write an algorithm to do depth first search in a graph.
Question 87 : Write an algorithm to do breadth first search in a graph.
Question 88 : Explain Dijkstra algorithm from source to all other vertices.
Question 89 : Explain Bellman Ford algorithm to find shortest distance
Question 90 : Explain Kruskal’s algorithm for finding minimum spanning tree
# Dynamic Programming
Question 91 : Given two String, find longest common substring.
Question 92 : Given two Strings A and B. Find the length of the Longest Common Subsequence (LCS) of the given Strings.
Question 93 : Given a matrix, we need to count all paths from top left to bottom right of MxN matrix. You can either move down or right.
Question 94 : Edit Distance Problem in java
Question 95: Coin change problem in java
Question 96 : Minimum number of jumps to reach last index
# Miscellaneous
Question 97 : What is an algorithm and how to calculate complexity of algorithms.
Question 98 : Implement trie data structure in java.
Question 99 : Count Factorial Trailing Zeroes in java.
Question 100 : Largest Rectangular Area in a Histogram.
Question 101 : Check for balanced parentheses in an expression in java.
Question 102 : What is Memoization.
Swap two numbers without using the third variable? (solution)
Check if two rectangles overlap with each other? (solution)
Design a Vending Machine? (solution)
Implement an LRU Cache in your favorite programming language? (solution)
Check if a given number is a Palindrome? (solution)
Check if a given number is an Armstrong number? (solution)
Find all prime factors of a given number? (solution)
Check if a given number is positive or negative in Java? (solution)
Find the largest prime factor of a given integral number? (solution)
Print all prime numbers up to a given number? (solution)
Print Floyd's triangle? (solution)
Print Pascal's triangle? (solution)
Calculate the square root of a given number? (solution)
Check if the given number is a prime number? (solution)
Add two numbers without using the plus operator in Java? (solution)
Check if a given number is even/odd without using an Arithmetic operator? (solution)
Print a given Pyramid structure? (solution)
Find the highest repeating world from a given file in Java? (solution)
Reverse a given Integer in Java? (solution)
Convert a decimal number to binary in Java? (solution)
Check if a given year is a leap year in Java? (solution)


# Bubble Sort

Difficulty Level : Easy

Last Updated : 30 Sep, 2020

Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.

Example:

First Pass:

( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1.

( 1 5 4 2 8 ) –>  ( 1 4 5 2 8 ), Swap since 5 > 4

( 1 4 5 2 8 ) –>  ( 1 4 2 5 8 ), Swap since 5 > 2

( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.

Second Pass:

( 1 4 2 5 8 ) –> ( 1 4 2 5 8 )

( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2

( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )

( 1 2 4 5 8 ) –>  ( 1 2 4 5 8 )

Now, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.

Third Pass:

( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )

( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )

( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )

( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )




![bubblesort](https://user-images.githubusercontent.com/37740006/109398276-1f149600-7966-11eb-8468-9238f21e716e.jpeg)

```java
package dataStructureAndAlgorithm.Sorting.BubbleSort;

public class _1_BubbleSort {

	public static void main(String[] args) {
		_1_BubbleSort obj = new _1_BubbleSort();
		int array[] = { 10, 7, 9, 2, 8, 3, 5, 4, 6, 1 };
		obj.printArray(array);
		obj.sort(array);
		System.out.println();
		obj.printArray(array);
	}

	private void sort(int[] array) {
		for (int i = 0; i < array.length - 1; i++) {
			for (int j = 0; j < array.length - i - 1; j++) {
				if (array[j] > array[j + 1]) {
					int temp = array[j];
					array[j] = array[j + 1];
					array[j + 1] = temp;
				}

			}
		}

	}

	private void printArray(int[] array) {
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}
	}

}
```
# Insertion Sort
## Algorithm  : Time Complexity O(n*n)
To sort an array of size n in ascending order: 
1. Iterate from arr[1] to arr[n] over the array. 
2. Compare the current element (key) to its predecessor. 
3. If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.

![insertionsort](https://user-images.githubusercontent.com/37740006/109120676-73562500-7770-11eb-9f6e-a9222bd1eb11.png)
```java
package dataStructureAndAlgorithm.Sorting.InsertionSort;

public class _2_InsertionSort {

	public static void rotateDigit(String[] args) {
		_2_InsertionSort obj = new _2_InsertionSort();
		int array[] = { 10, 7, 9, 2, 8, 3, 5, 4, 6, 1 };
		obj.printArray(array);
		obj.sort(array);
		System.out.println();
		obj.printArray(array);
	}

	private void sort(int[] array) {
		for (int i = 0; i < array.length; i++) {
			int j = i;
			while (j > 0 && array[j - 1] > array[j]) {
				int temp = array[j];
				array[j] = array[j - 1];
				array[j - 1] = temp;
				j--;

			}
		}
	}

	private void printArray(int[] array) {
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}
	}

}
```
# Selection Sort
1. Not Stable
2. In Place

## Time Complexity : O(n*n)

## Algoritm : 

1.we search for the lowest element and arrange it to the proper location. 

2.We swap the current element with the next lowest number.

![selection-sort (1)](https://user-images.githubusercontent.com/37740006/109400083-d44c4b80-7970-11eb-95d2-ff4526ef5772.png)

```java
// https://www.javatpoint.com/selection-sort-in-java
// https://www.geeksforgeeks.org/selection-sort/
// See video of geeks for geeks
/***************************************************************************
	Selection sort finds the maximum or the minimum value from the array and 
	exchanges it with the element at the end of the array.
	Then it finds the maximum value form the array except the last one and
	exchanges it with th second to the last element.
	
	// First Run:
	 * 5  4  3   2   1  // since 5 is the maximum value it exchanges with the last element 1
	// Second Run:
	 * 1  4  3   2|   5 // since 4 is the maximum value it exchanges with the last element 1
	// Third Run:
	 * 1  2  3|   4    5 :Sorting complete
 ****************************************************************************/
package dataStructureAndAlgorithm.Sorting.SelectionSort;

public class SelectionSortAlgorithm {

	public static void selectionSort(int[] arr) {
		// One by one move boundary of unsorted subarray
		for (int i = 0; i < arr.length - 1; i++) {
			// Find the minimum element in unsorted array
			int index = i;
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[j] < arr[index]) {
					index = j;// searching for lowest index

				}

			}
			// Swap the found minimum element with the first
			// element
			int temp = arr[i];
			arr[i] = arr[index];
			arr[index] = temp;
		}

	}

	private static void printArray(int[] array) {
		for (int i = 0; i < array.length; i++) {
			System.out.print(array[i] + " ");
		}

	}

	public static void main(String[] args) {
		int array[] = { 5, 4, 3, 2, 1 };

		System.out.println("Before sort:");
		printArray(array);

		selectionSort(array);

		System.out.println("\n\nAfter Selection sort:");
		printArray(array);

	}
}
```
# QUICK SORT
There are many different versions of quickSort that pick pivot in different ways.

1. Always pick first element as pivot.
2. Always pick last element as pivot 
3. Pick a random element as pivot.
4. Pick median as pivot.(implemented below)

## Time Complexities

**Worst Case Complexity [Big-O]: O(n2)**

It occurs when the pivot element picked is either the greatest or the smallest element.

This condition leads to the case in which the pivot element lies in an extreme end of the sorted array. 

One sub-array is always empty and another sub-array contains n - 1 elements. Thus, quicksort is called only on this sub-array.

However, the quick sort algorithm has better performance for scattered pivots.

**Best Case Complexity [Big-omega]: O(n*log n)**

It occurs when the pivot element is always the middle element or near to the middle element.

**Average Case Complexity [Big-theta]: O(n*log n)**

It occurs when the above conditions do not occur.

## Pick median as pivot / Middle as Pivot


![011019_1052_QuickSortAl2](https://user-images.githubusercontent.com/37740006/109401823-25613d00-797b-11eb-854b-265646be943d.png)



```java
package dataStructureAndAlgorithm.Sorting.QuickSort;

import java.util.Arrays;

public class _5_QuickSort {

	public static void main(String[] args) {
		int array[] = { 9, 6, 7, 4, 1, 3, 2 };
		System.out.println("Before Sorted Array...");
		System.out.println(Arrays.toString(array));
		int high = array.length - 1;
		quickSort(array, 0, high);

		System.out.println("\nAfter Sorted");
		System.out.println(Arrays.toString(array));
	}

	private static void quickSort(int[] array, int low, int high) {
		if (low >= high) {
			return;
		}
		int middle = low + (high - low) / 2;
		int pivot = array[middle];

		int index = partition(array, low, high, pivot);
		quickSort(array, low, index - 1);
		quickSort(array, index, high);

	}

	private static int partition(int[] array, int low, int high, int pivot) {
		while (low <= high) {
			while (array[low] < pivot) {
				low++;
			}
			while (array[high] > pivot) {
				high--;
			}

			if (low <= high) {
				int temp = array[low];
				array[low] = array[high];
				array[high] = temp;
				low++;
				high--;
			}
		}
		return low;
	}

}
```
# Merge Sort

1. Merge Sort is a Divide and Conquer algorithm. 

2. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.

## Merge Sort Complexity
## Time Complexity

**Best Case Complexity: O(n*log n)**

**Worst Case Complexity: O(n*log n)**

**Average Case Complexity: O(n*log n)**

Space Complexity
The space complexity of merge sort is O(n).

```
MergeSort(arr[], l,  r)
If r > l
     1. Find the middle point to divide the array into two halves:  
             middle m = l+ (r-l)/2
     2. Call mergeSort for first half:   
             Call mergeSort(arr, l, m)
     3. Call mergeSort for second half:
             Call mergeSort(arr, m+1, r)
     4. Merge the two halves sorted in step 2 and 3:
             Call merge(arr, l, m, r)
 ```
 
![Merge-Sort-Tutorial](https://user-images.githubusercontent.com/37740006/109424994-66576100-7a10-11eb-9d64-b6c23b075b40.png)

Node.java
```java
package dataStructureAndAlgorithm.Sorting.MergeSort;

public class Node {
	Node head;
	int data;
	Node next;
	int length = 0;

	Node(int data) {
		this.data = data;
		this.next = null;
	}

	Node() {

	}

	void display(Node head) {
		Node current = head;
		while (current != null) {
			System.out.print(current.data + "-->");
			current = current.next;
		}
		System.out.println(current);
	}

	/*
	 * Node push(int i) { Node newNode = new Node(i); newNode.next = head; head =
	 * newNode; length++; return this; }
	 */
	void insertAtlast(int data) {
		Node node = new Node(data);
		if (head == null) {
			head = node;
		} else {
			Node currentNode = head;
			while (currentNode.next != null) {
				currentNode = currentNode.next;
			}
			currentNode.next = node;
		}

	}

	public int getLength() {
		return length;
	}
}
```
MergeSort.java
```java
package dataStructureAndAlgorithm.Sorting.MergeSort;

public class MergeSort {

	static Node merge(Node left, Node right) {
		if (left == null)
			return right;
		if (right == null)
			return left;

		Node result = null;

		if (left.data <= right.data) {
			result = left;
			result.next = merge(left.next, right);
		} else {
			result = right;
			result.next = merge(left, right.next);
		}
		return result;
	}

	static Node mergeSort(Node head) {
		if (head == null || head.next == null)
			return head;

		Node middle = getMiddle(head);
		Node nextofmiddle = middle.next;
		middle.next = null;
		Node left = mergeSort(head);
		Node right = mergeSort(nextofmiddle);
		Node sortedlist = merge(left, right);
		return sortedlist;
	}

	static Node getMiddle(Node head) {
		if (head == null)
			return head;
		Node fastPtr = head.next;
		Node slowPtr = head;

		while (fastPtr != null && fastPtr.next != null) {
			slowPtr = slowPtr.next;
			fastPtr = fastPtr.next.next;
		}
		return slowPtr;
	}

	public static void main(String[] args) {

		Node list = new Node();
		list.insertAtlast(38);
		list.insertAtlast(27);
		list.insertAtlast(9);
		list.insertAtlast(3);
		list.insertAtlast(82);
		// nodeRef.push(10).push(82).push(9).push(3).push(43).push(27).push(38);

		System.out.print("UNSorted Linked List is: ");
		list.display(list.head);

		list.head = mergeSort(list.head);

		System.out.print("Sorted Linked List is: ");
		list.display(list.head);
	}
}
```
# Binary Search

```
We basically ignore half of the elements just after one comparison.

Compare x with the middle element.

If x matches with middle element, we return the mid index.

Else If x is greater than the mid element, then x can only lie in right half subarray after the mid element. So we recur for right half.

Else (x is smaller) recur for the left half.
```
```java

package dataStructureAndAlgorithm.Search.Binary;

//Java implementation of iterative Binary Search 
public class BinarySearch {
	// Java implementation of iterative Binary Search
	// Returns index of x if it is present in arr[],
	// else return -1
	int binarySearch(int arr[], int x) {
		int l = 0, r = arr.length - 1;
		while (l <= r) {
			int m = l + (r - l) / 2;

			// Check if x is present at mid
			if (arr[m] == x)
				return m;

			// If x greater, ignore left half
			if (arr[m] < x)
				l = m + 1;

			// If x is smaller, ignore right half
			else
				r = m - 1;
		}

		// if we reach here, then element was
		// not present
		return -1;
	}

	// Driver method to test above
	public static void main(String args[]) {
		BinarySearch ob = new BinarySearch();
		int arr[] = { 2, 3, 4, 10, 40 };
		int n = arr.length;
		int x = 10;
		int result = ob.binarySearch(arr, x);
		if (result == -1)
			System.out.println("Element not present");
		else
			System.out.println("Element found at " + "index " + result);
	}
}
```
## Recursion
```java
package dataStructureAndAlgorithm.Search.Binary;

//Java implementation of iterative Binary Search 
public class BinarySearchRecursive {
	// Java implementation of recursive Binary Search
	// Returns index of x if it is present in arr[l..
	// r], else return -1
	int binarySearch(int arr[], int l, int r, int x) {
		if (r >= l) {
			int mid = l + (r - l) / 2;

			// If the element is present at the
			// middle itself
			if (arr[mid] == x)
				return mid;

			// If element is smaller than mid, then
			// it can only be present in left subarray
			if (arr[mid] > x)
				return binarySearch(arr, l, mid - 1, x);

			// Else the element can only be present
			// in right subarray
			return binarySearch(arr, mid + 1, r, x);
		}

		// We reach here when element is not present
		// in array
		return -1;
	}

	// Driver method to test above
	public static void main(String args[]) {
		BinarySearchRecursive ob = new BinarySearchRecursive();
		int arr[] = { 2, 3, 4, 10, 40 };
		int n = arr.length;
		int x = 10;
		int result = ob.binarySearch(arr, 0, n - 1, x);
		if (result == -1)
			System.out.println("Element not present");
		else
			System.out.println("Element found at index " + result);
	}
}
```
# Stack Data Structure
Stack is a linear data structure which follows a particular order in which the operations are performed. 

The order may be **LIFO(Last In First Out) or FILO(First In Last Out)**

# Basic Operations

Stack operations may involve initializing the stack, using it and then de-initializing it. 

Apart from these basic stuffs, a stack is used for the following two primary operations −

**push() − Pushing (storing) an element on the stack.**

**pop() − Removing (accessing) an element from the stack.**

When data is PUSHed onto stack.

To use a stack efficiently, we need to check the status of stack as well. For the same purpose, the following functionality is added to stacks −

**peek() − get the top data element of the stack, without removing it.**

**isFull() − check if stack is full.**

**isEmpty() − check if stack is empty.**



<img width="407" alt="stack" src="https://user-images.githubusercontent.com/37740006/109570828-e7981c00-7b14-11eb-8a75-b505788b125b.png">

# LinkedList Implementation of Stack

```java
package dataStructureAndAlgorithm.Stack.LinkedListImplementation;

class Node {
	int data;
	Node nextNode;

	public Node(int data) {
		this.data = data;
	}

}
```
```java
package dataStructureAndAlgorithm.Stack.LinkedListImplementation;

class Stack {
	Node topNode;
	int length;

	public Stack() {
		topNode = null;
		length = 0;
	}

	public void push(int data) {
		Node node = new Node(data);
		node.nextNode = topNode;
		topNode = node;
		length++;
	}

	public int pop() {
		if (isEmpty()) {
			System.out.println("Stack is empty..");
		}

		int data = topNode.data;
		topNode = topNode.nextNode;
		length--;
		return data;

	}

	public int peek() {
		if (isEmpty()) {
			System.out.println("Stack is empty..");
		}

		return topNode.data;
	}

	public void show() {
		Node currentNode = topNode;
		while (currentNode != null) {
			System.out.print(currentNode.data + " ");
			currentNode = currentNode.nextNode;
		}
		System.out.println();
	}

	public int length() {
		return length;
	}

	public boolean isEmpty() {
		return length == 0;
	}
  }
  ```
  ```java
package dataStructureAndAlgorithm.Stack.LinkedListImplementation;


public class Main {

	public static void main(String args[]) {
		Stack stack = new Stack();
		System.out.println("Stack implementation using LinkedList..\n");
		System.out.println("Length of the stack is: " + stack.isEmpty());
		stack.push(8); // 0
		stack.push(6); // 1
		stack.push(7); // 2
		stack.show();
		System.out.println("Length of the stack is: " + stack.length());

		System.out.println("Pop element is : " + stack.pop());
		stack.show();
		System.out.println("Length of the stack is: " + stack.length());

		System.out.println("Pop element is : " + stack.pop());
		stack.show();
		System.out.println("Length of the stack is: " + stack.length());

		System.out.println("peek element is : " + stack.peek());

	}

}
/*
 * Output: Stack implementation using LinkedList..
 * 
 * Length of the stack is: true 7 6 8 Length of the stack is: 3 Pop element is :
 * 7 6 8 Length of the stack is: 2 Pop element is : 6 8 Length of the stack is:
 * 1 peek element is : 8
 */
 ```
# Queue Data Structure

A Queue is a linear structure which follows a particular order in which the operations are performed. The order is 

## First In First Out (FIFO).

# Basic Operations

Queue operations may involve initializing or defining the queue, utilizing it, and then completely erasing it from the memory. 

Here we shall try to understand the basic operations associated with queues −

**enqueue() − add (store) an item to the queue.**

**dequeue() − remove (access) an item from the queue.**

Few more functions are required to make the above-mentioned queue operation efficient. These are −

**peek() − Gets the element at the front of the queue without removing it.**

**isfull() − Checks if the queue is full.**

**isempty() − Checks if the queue is empty**

![Queue](https://user-images.githubusercontent.com/37740006/109572643-cedd3580-7b17-11eb-9548-88df0df5a1a8.png)


# LinkedList Implementation
## Node.java
```java
package dataStructureAndAlgorithm.Queue.LinkedListRepresentation;

public class Node {
	int data;
	Node nexNode;

	public Node(int data) {
		this.data = data;
		this.nexNode = null;
	}

}
```
## Queue.java
```java
package dataStructureAndAlgorithm.Queue.LinkedListRepresentation;

public class Queue {
	Node frontNode;
	Node rearNode;
	int length;

	public Queue() {

		this.frontNode = null;
		this.rearNode = null;
		this.length = 0;
	}

	public int length() {
		return length;
	}

	public boolean isEmpty() {
		return length == 0;
	}

	// inserting the value to the rear
	public void enqueue(int data) {
		Node node = new Node(data);
		if (isEmpty()) {
			frontNode = node;
		} else {
			rearNode.nexNode = node;
		}
		rearNode = node;
		length++;

	}

	// dequeue / delete the value from the queue ..
	public int dequeue() {
		if (isEmpty()) {
			System.out.println("No valuee in the list..");
		}
		int result = frontNode.data;
		frontNode = frontNode.nexNode;
		if (frontNode == null) {
			rearNode = null;
		}
		length--;
		return result;
	}

	// display the value..
	public void show() {
		Node currentNode = frontNode;
		while (currentNode != null) {
			System.out.print(currentNode.data + "--->");
			currentNode = currentNode.nexNode;
		}
		System.out.println(currentNode);

	}

}
```
## Main.java
```java
package dataStructureAndAlgorithm.Queue.LinkedListRepresentation;

public class Main {

	public static void main(String[] args) {
		Queue queue = new Queue();
		queue.enqueue(10);
		queue.enqueue(5);
		queue.enqueue(9);
		queue.show();
		queue.dequeue();
		queue.show();
	}

}
// 10--->5--->9--->null
// 5--->9--->null
```
# Binary Tree
Binary Tree: A tree whose elements have at most 2 children is called a binary tree. 
Since each element in a binary tree can have only 2 children, we typically name them the left and right child. 

**Full Binary Tree A Binary Tree is a full binary tree if every node has 0 or 2 children. The following are the examples of a full binary tree. We can also say a full binary tree is a binary tree in which all nodes except leaf nodes have two children.** 

               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40

             18
           /    \   
         15     20    
        /  \       
      40    50   
    /   \
    30   50

               18
            /     \  
          40       30  
                   /  \
                 100   40
**Complete Binary Tree: A Binary Tree is a Complete Binary Tree if all the levels are completely filled except possibly the last level and the last level has all keys as left as possible**

The following are examples of Complete Binary Trees 



               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Practical example of Complete Binary Tree is Binary Heap. 

**Perfect Binary Tree A Binary tree is a Perfect Binary Tree in which all the internal nodes have two children and all leaf nodes are at the same level. 
The following are the examples of Perfect Binary Trees.** 

               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40


               18
           /       \  
         15         30  
![1614116225893](https://user-images.githubusercontent.com/37740006/108914979-65ac7c80-7656-11eb-8243-0d5eceffcf98.jpg)
# Binary Tree LinkedList Implementation

```.java
package dataStructureAndAlgorithm.Tree.BinaryTree.traversal.AllTraversalInOneFile;

import java.util.Stack;

class Node {
    Node left;
    Node right;
    int data;

    public Node(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

public class BinaryTree {
    Node root;

    private void createBinaryTree() {
        Node first = new Node(9);
        Node second = new Node(2);
        Node third = new Node(3);
        Node fourth = new Node(4);
        Node fifth = new Node(5);

        // join node
        root = first;
        first.left = second;
        first.right = third;
        second.left = fourth;
        second.right = fifth;

    }

    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();
        binaryTree.createBinaryTree();
        System.out.println("PreOrder ");
        binaryTree.preOrder(binaryTree.root);

        System.out.println("\nPreOrder Iterator ");
        binaryTree.preOrderItr(binaryTree.root);

        System.out.println("\nIn Order");
        binaryTree.inOrder(binaryTree.root);

        System.out.println("\nIn Order");
        binaryTree.inOrderItr(binaryTree.root);

        System.out.println("\nPost Order");
        binaryTree.postOrder(binaryTree.root);

        System.out.println("\nPost Order");
        binaryTree.postOrderItr(binaryTree.root);

    }

    private void preOrderItr(Node root) {

        Stack<Node> stack = new Stack<>();
        stack.push(root);

        while (!stack.isEmpty()) {
            Node tempNode = stack.pop();
            System.out.print(tempNode.data + " ");

            if (tempNode.right != null) {
                stack.push(tempNode.right);
            }
            if (tempNode.left != null) {
                stack.push(tempNode.left);
            }
        }
    }

    private void postOrder(Node root) {
        // TODO Auto-generated method stub
        if (root == null) {
            return;
        }
        postOrder(root.left);
        postOrder(root.right);
        System.out.print(root.data + " ");
    }

    private void postOrderItr(Node root) {
        if (root == null) {
            return;
        }

        Stack<Node> stack = new Stack<>();
        stack.push(root);

        Stack<Node> out = new Stack<>();

        while (!stack.isEmpty()) {
            Node cuNode = stack.pop();
            out.push(cuNode);
            if (cuNode.left != null) {
                stack.push(cuNode.left);
            }
            if (cuNode.right != null) {
                stack.push(cuNode.right);
            }
        }

        while (!out.isEmpty())
            System.out.print(out.pop().data + " ");

    }

    private void inOrder(Node root) {
        if (root == null) {
            return;
        }
        inOrder(root.left);
        System.out.print(root.data + " ");
        inOrder(root.right);

    }

    private void inOrderItr(Node root) {
        if (root == null) {
            return;
        }
        Stack<Node> stack = new Stack<>();
        Node current = root;

        while (current != null || !stack.isEmpty()) {
            if (current != null) {
                stack.push(current);
                current = current.left;
            } else {
                current = stack.pop();
                System.out.print(current.data + "-->");
                current = current.right;
            }
        }
    }

    private void preOrder(Node root) {
        if (root == null) {
            return;
        }
        System.out.print(root.data + " ");
        preOrder(root.left);
        preOrder(root.right);

    }

}
```
# BFS
```java
public void traverseLevelOrder() {
    if (root == null) {
        return;
    }

    Queue<Node> nodes = new LinkedList<>();
    nodes.add(root);

    while (!nodes.isEmpty()) {

        Node node = nodes.remove();

        System.out.print(" " + node.value);

        if (node.left != null) {
            nodes.add(node.left);
        }

        if (node.right != null) {
            nodes.add(node.right);
        }
    }
}

```
# How to Find all Pairs in Array of Integers Whose sum is Equal to a Given Number
```java

// https://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html#axzz6oGvH3QQv

package new_100_Problems;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class _16_FindPairOfIntegerOfGivenString {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 10, 5, 6, 10, 7, 8};
        findPairOfGivenSum(arr, 15);

        System.out.println("--------------");
        findPairUsingSet(arr, 15);
        System.out.println("--------------");
        findPairUsingSetII(arr,15);

        System.out.println("--------------");
        findPairUsingSorting(arr, 15);


    }

    private static void findPairOfGivenSum(int[] arr, int result) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] + arr[j] == result) {
                    System.out.println(arr[i] + " " + arr[j]);
                }
            }
        }
    }


    private static void findPairUsingSet(int[] numbers, int n) {
        if (numbers.length < 2) {
            return;
        }
        Set<Integer> set = new HashSet<>(numbers.length);
        for (int value : numbers){
            set.add(value);
        }
        for (int value : numbers) {
            int target = n - value; // if target number is not in set then add
            if (set.contains(target)) {
                System.out.printf("(%d, %d) %n", value, target);
            }
        }
        // Read more: https://javarevisited.blogspot.com/2014/08/how-to-find-all-pairs-in-array-of-integers-whose-sum-equal-given-number-java.html#ixzz6oPhF3sYh
    }

    private static void findPairUsingSetII(int[] numbers, int n){
        Set<Integer> set = new HashSet<>();
        for (int i : numbers)
        {
            int target = n - i;
            if (!set.contains(target)){
                set.add(i);
            }else {
                System.out.println(i +" "+target);
            }
        }
    }


    private static void findPairUsingSorting(int[] arr, int sum) {
        Arrays.sort(arr);
        int left = 0;
        int right = arr.length - 1;
        for (int i : arr) {
            if (arr[left] + arr[right] == sum) {
                System.out.println(arr[left] + " " + arr[right]);
            }
            if (arr[left] + arr[right] > sum) {
                right--;
            } else {
                left++;
            }
        }
    }


}
```
